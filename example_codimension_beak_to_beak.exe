LIB "teachstd.lib";
LIB "polylib.lib";
LIB "ainvar.lib";
LIB "crypto.lib";
LIB "zeroset.lib";

LIB "cssm_multi_std.lib";
LIB "addcons.lib";
LIB "local_cohomology.lib";
LIB "cgs.lib";
LIB "check_zeros.lib";
LIB "simplify_constructible.lib";
LIB "combine_locally_closed.lib";
LIB "gauss_elimination.lib";

int nx = 3;
int ny = 2;
int i,j,k,l;
intmat imat[nx+ny][nx+ny];
for(i=1;i<=nx+ny;i++){
	imat[1,i] = -1;
}
for(i=1;i<=ny;i++){
	imat[i+1,ny+nx-i+1] = 1;
}
for(i=1;i<=nx-1;i++){
	imat[i+ny+1,nx-i+1] = 1;
}
ring R = (0,a), (x(1..nx),y(1..ny)), (M(imat),C);
list X = list();
for(i=1;i<=ny;i++){
	X[i] = ideal(y(i));
	X[i] = std(X[i]);
}
X[ny+1] = ideal(0);

// computing eta (for details, see the paper.).
intmat eta[ny+1][ny+1];
ideal Xij;
for(i=1;i<=ny+1;i++){
	eta[i,i] = i;
	for(j=i+1;j<=ny+1;j++){
		Xij = std(reduce(intersect(X[i],X[j]),maxideal(2)));
		for(k=1;k<=ny+1;k++){ 
			if(size(reduce(Xij,X[k])) == 0 && size(reduce(X[k],Xij)) == 0){
				eta[i,j] = k;
				break;
			}
		}
		eta[j,i] = eta[i,j];	
	}
}

ideal E = 0;
ideal N = 1;

int K = 4;
int ell = 3;
poly f(1..ny);
f(1) = x(1);
f(2) = x(2)^3+x(2)*x(1)^ell+x(1)+x(3)^2;
vector f;
for(i=1;i<=ny;i++){
	f = f + f(i)*gen(i);
}

// option(prot);
ideal zero;
for(i=1;i<=ny;i++){
	zero = zero, y(i)-f[i];
}
zero = compress(zero);
module TR;
for(i=1;i<=nx;i++){
	TR = TR, diff(f,x(i));
}
TR = compress(TR);
ideal mx = x(1..nx);
ideal my = y(1..ny);
module TR1K = TR + zero*freemodule(ny) + mx^(K+1)*freemodule(ny);

// Q[i]: generators of component X_{i+1} in the paper, which is X[i]-module
list Q;
Q[1] = module(gen(1));
Q[2] = module(gen(2));
Q[3] = module(vector(0));

list Lg = cssm(X,eta,E,N,TR1K,Q);
for(i=1;i<=size(Lg);i++){
	Lg[i][1] = radical_ideal(Lg[i][1]);
	Lg[i][2] = radical_ideal(Lg[i][2]);
}
Lg;

for(i=1;i<=size(Lg);i++){
	print("E :");
	Lg[i][1];
	print("N :");
	Lg[i][2];
	print("quotients :");
	kbase_mixed(X,Lg[i]);
}

quit;
